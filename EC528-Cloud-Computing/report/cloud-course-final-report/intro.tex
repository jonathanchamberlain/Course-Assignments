In recent decades, virtualization of resources has emerged as a means to run multiple OSes on the same hardware. Indeed, Virtual Machines (VMs) are \emph{taken to be an efficent, isolated duplicate of the real machine} \cite{Popek:1974:FRV:361011.361073}. This serves a useful function by permitting multiple applications to coexist on the same server, enabling efficiencies in computing such as server consolidation. Traditional VMs virtualize hardware resources; while this achieves the goal of isolating the VM, it can result in inefficiencies when multiple VMs are running, on the same hardware. This especially holds if the VMs are running multiple instances of the same application. In response to this, containerization has been developed in order to achieve operating system-level virtualization. By sharing OS resources, containers are lightweight and can be spun up quickly. As this resource sharing significantly reduces the need to reproduce the OS code, containers take up far fewer resources. This also leads to the advantage of servers running multiple workloads with a single operating system installation.


In order to implement virtualization at the OS level, Containers make use of Linux namespaces and cgroups. \textbf{Namespaces} permit the vritualization of resources in each container, such as networking or the underlying file system. \textbf{Cgroups} are a feature of the Linux kernel which provide a way to limit and isolate resource usage per container. \cite{lewis_2017}Â  However, this proved to be largely difficult until the development of Docker. Released in 2013, Docker addresses end-to-end management of containers including defining a container image format and a means to build images, the ability to manage and share images, and manage and run containers. However, none of these features were necessarily dependant on each other. Rather than being packaged into a single monolithic application, each could be implemented as a series of more focused tools which can be used together in whatever combination the user needs \cite{lewis_2017}.  

To that end, industry leaders (including Docker) established the Open Container Initiative (OCI) in June of 2015. OCI consists of a Runtime Specification and an Image Specification. \cite{open_containers_initiative_2016}. These specifications cover the downloading and unpacking of images into an OCI Runtime Filesystem bundle. No uniform standard exists to manage lifecycle functionality; although minimum requirements exist on behavior of certain commands, \emph{how} they are implemented is largely left up to the runtime developer \cite{opencontainers_runtime-spec_2017}. Because OCI does not fully standardize lifecycle management of containers, each container runtime implements this functionality in a different manner. In particular, this results in a lack of consistent standards for the security of containers, as OCI does not include these in its own specifications, and many security concerns are related to lifecycle management.

In this project, we studied the differences in three of the most popular runtimes: Docker, containerd, and cri-o. From this, we developed an interoperable application focused on performing certain industry standard security checks across runtimes. In particular, our focus is on ensuring that the benchmarks specified by the Center for Internet Security (CIS) for Docker are satisfied in cri-o and containerd \cite{center_for_internet_security}.

\subsection*{Vision and Goals}


Currently if someone wishes to launch an image in a container or perform any other lifecycle management functions on it, they must be sure that the scripts are configured correctly for the target container. For instance, launching images in Docker differs from doing so in crio or containerd. This locks individuals and businesses into whichever container runtime they started with unless they invest the time required to edit the configuration and their scripts which holds the commands for target container.

In particular, in order to evaluate security properties, such as whether memory usage is limited, or AppArmor is enabled, it is necessary to either run the necessary commands by hand, or update validation scripts to reflect the new runtime in use. Our goals for this project were to develop an application capable of running standard security checks \cite[Ch.5]{center_for_internet_security} on the container. Publishing a minimum viable framework for this purpose will enable users to run their security checks using a single application across the most popular containers. 

In the longer term, this would enable automation of these checks via implementing the application within a service running on each cluster hosting containers. Doing so however was beyond the scope of our immediate project due to time constraints; we discuss in our concluding section the future directions of the project in terms of the longer term vision as well as next steps. 

\subsection*{Users/Personas of the Project}


The intended user is the Chief Information Security Officer or their designee of a medium- or large-scale cloud organization, who is tasked with ensuring that containers running their clusters meet requirements for secure containers. 


\subsection*{Scope}


The runtimes within our scope are Docker, cri-o, and containerd. Our MVP was to implement five of the benchmarks related to container runtimes within Docker and cri-o \cite[Ch. 5]{center_for_internet_security}. Ultimately, we were able to configure the application so that 23 benchmarks are evaluated for Docker, 20 for cri-o, and 16 for containerd. Some benchmarks were determined to be Docker specific and not applicable to the other runtimes, others require additional evaluation to determine how to implement. A more detailed discussion of the implementation for individual benchmarks is contained in the section on the Interoperable Application can be found in later sections and appendix. 

In addition to implementation of more than five container runtime benchmark checks, our stretch goal also included implementing benchmark checks for container images/image files \cite[Ch. 4]{center_for_internet_security} across Docker, cri-o, and containerd. Ultimately, we were able to implement five of the eleven image file benchmarks within Docker, and three within cri-o. Discussion of the challenges for the image file benchmarks are contained in the section on the image file benchmark definitions.