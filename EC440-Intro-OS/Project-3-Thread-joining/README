THREADS.C

THIS PROGRAM IMPLEMENTS A PARTIAL THREAD LIBRARY TO CREATE THREADS. THIS THREAD LIMITS THREAD CREATION TO 128 THREADS TOTAL 
(PLUS A THREAD 0 FOR THE MAIN FUNCTION) 

THIS SECOND VERSION ADDS THE FOLLOWING FUNCITONALITY:

LOCK -
  THIS FUNCTION IS CALLED BY THE MAIN PROGRAM CREATING THE THREADS, AND IS USED TO PREVENT THE SCHEDULER FROM PREEMPTING A 
  THREAD WHILE IT IS IN A CRITICAL REGION. THIS IS ACCOMPLISHED BY USING SIGPROCMASK ON A SET CONSISTING OF SIGALRM TO BLOCK 
  SIGARLM FROM BEING RAISED.

UNLOCK - 
  THIS FUNCITON IS CALLED BY THE MAIN PROGRAM CREATING THE THREADS, AND IS USE TO RESUME THE SCHEDULER AFTER A THREAD HAS 
  EXITED A CRITICAL REGION. THIS IS ACCOMPLISHED BY USING SIGPROCMASK AGAIN ON A SET CONSISTING OF SIGALRM TO UNBLOCK SIGALRM.

PTHREAD_JOIN -
  THIS FUNCITON TAKES THE FOLLOWING INPUTS:
    THREAD - THE ID OF THE THREAD BEING JOINED TO
    **VALUE_PTR - A POINTER TO STORE THE RETURN VALUE
  
  WHEN CALLED, THIS FUNCTION WILL "JOIN" THREADS BY TAKING THE RETURN VALUE FROM THREAD ID THREAD, AND PASS IT INTO THE 
  VALUE_PTR, WHICH THEN ALLOWS THE RETURN VALUE TO BE REFERENCED IN THE THREAD CALLING PTHREAD_JOIN.

  IF THREAD HAS NOT YET EXITED, THE THREAD THAT CALLED PTHREAD_JOIN IS BLOCKED UNTIL THREAD EXITS. ON BLOCKING THE SCHEDULER 
  IS IMMEDIATELY CALLED TO PREVENT ADDITIONAL EXECUTION BY THE BLOCKING THREAD.

THE FOLLOWING FUNCTIONS HAVE BEEN UPDATED FROM THE ORIGIONAL VERSION:

PTHREAD_CREATE - 
  THIS FUCNTION TAKES THE FOLLOWING INPUTS:
	*THREAD - POINTER TO THREAD INDEX STRUCTRE IN MAIN
        *ATTR - ALWAYS SET TO NULL
        *START_ROUTINE - THE FUNCTION BEING EXECUTED IN THE THREAD BEING CREATED
        *ARG - THE ARGUMENT BEING PASSED TO START_ROUTINE
  PTHREAD_CREATE CREATES A NEW THREAD CONTROL BLOCK FOR EACH NEW THERAD. THE TCB IS CONTAINED IN THE ARRAY THREADS, WHICH IS 
  OF TYPE Thread, EACH ELEMENT CONSISTING OF THE FOLLOWING:
        TID - THE THREAD ID
        TENV - THE SAVED REGISTERS OF THE THERAD
        TSTACK - THE ALLOCATED MEMORY STACK
        STATUS - THE STATUS OF THE THREAD (READY, RUNNING, EXIT, OR BLOCKED)
        RETVAL - THE RETURN VALUE FROM THE FUNCTION EXECUTED IN THE THREAD
        BID - THE ID OF THE THREAD BLOCKED BY THE CURRENT THREAD 
        

  FOR EACH NEW THREAD, PTHREAD_CREATE SAVES THE THREAD ID (AN INT 1-128 BASED ON THE NUMBER OF THREADS ALREADY CREATED), 
  MALLOCS A BLOCK OF 32K WHICH IS SAVED IN TSTACK, AND SAVES POINTERS TO ARG AND PTHREAD_EXIT ON THE TOP OF THE STACK. 
  SETJMP IS THEN CALLED TO SAVE THE REGISTERS, WHICH IS SUBSEQUENTLY MODIFIED TO POINT TO THE CREATED TSTACK, AND THE 
  SPECIFIED START_ROUTINE. THE STATUS OF THE THREAD IS SET TO READY SO IT CAN BE SCHEDULUED.

  ON STARTUP, THE MAIN FUNCTION IS SAVED IN ELEMENT 0 OF THREADS; IT'S SETJMP BUFFER IS NOT MODIFIED, AND A STACK IS NOT 
  CREATED, AS MAIN ALREADY HAS A STACK AND THE REGISTERS POINT TO MAIN BY DEFAULT SINCE THAT IS WHERE THE THREADS ARE BEING 
  CREATED FROM. THREADS[0] IS THEN SET TO READY. THE SCHEDULUER HANDLER IS INITIALIZED, AND A 50MS UALARM CALLED TO TRIGGER 
  THREAD SWITCHING.

PTHREAD_EXIT -
  THIS FUNCTION TAKES THE FOLLOWING INPUT:
	*VALUE_PTR - POINTER FROM THE CALLING FUNCTION.

  THE THREAD FREES THE PREVIOUSLY ALLOCATED MEMORY, SAVES THE REUTRN VALUE OF THE EXITING THREAD (PASSED IN THE VALUE_PTR INPUT)
  INTO RETVAL, UNBLOCKS ANY THREADS WAITING ON THIS ONE. AND SETS THE THREAD STATUS TO EXIT. SCHEDULE IS THEN CALLED TO RUN THE
  NEXT READY THREAD. THIS FUNCTION IS CALLED WHEN EACH THREAD RETURNS AS A RESULT OF THE STACK MANIPULATION IN PTHREAD_CREATE -
  THREAD[0] (THE MAIN FUNCTION) WILL NOT CALL THIS FUNCTION, AND INSTEAD EXIT NORMALLY.


THE FOLLOWING FUNCTIONS ARE CARRIED OVER FROM THE ORIGIONAL VERSION:

SCHEDULE -
  THIS FUNCTION IS TRIGGERED ON A SIGALRM EVERY 50MS USING A SIGACTION HANDLER AND STRUCT AND UALARM INTIALIZED WHEN CREATING 
  THE MAIN THREAD IN PTHREAD_CREATE. THIS FUNCTION CALLS SETJMP ON THE CURRENTLY RUNNING THREAD TO SAVE THE CONTEXT, 
  LOOPS THROUGH THE THREADS AND FINDS THE NEXT THREAD IN A READY STATE, THEN EXECUTES THE THREAD VIA A LONGJMP CALL.

SCHHANDLER -
  THIS FUNCTION IS A WRAPPER TO TRIGGER A CALL TO SCHEDULE WHEN SIGARLM GOES OFF - THE SIGACTION FOR SIGALRM POINTS TO THIS 
  FUNCTION AS THE HANDLER, WHICH THEN CALLS SCHEDULE AS ITS ONLY COMMAND.

PTHREAD_SELF - 
  THIS FUNCTION RETURNS THE ID OF THE CURRENTLY RUNNING THREAD.


THE FOLLOWING WERE INTENDED TO BE IMPLEMENTED WITH THIS VERSION BUT WERE NOT. THE REASON FOR NON IMPLEMENTATION IS DUE TO 
THE FACT THAT IT IS NECESSARY TO CREATE A CUSTOM STRUCTURE TO HOLD THE RELEVANT SEMAPHORE INFORMATION (ACTIVE STATUS, 
THE CURRENT VALUE, AND THE QUEUE OF THREADS WAITING ON THE SEMAPHORE). BECAUSE THE SEM_T TYPE DOES NOT HAVE THESE FIELDS, 
A CUSTOM STRUCT MUST BE CREATED, AND THEN SEM_T'S ALIGN MUST THEN POINT TO THE MEMORY ADDRESS OF THE STRUCTURE. HOWEVER, 
I WAS UNABLE TO DETERMINE HOW TO IMPLEMENT THIS IN SUCH A MANNER THAT THE SEM_T WOULD RETAIN A VALID REFERENCE TO SAID STRUCT - 
IT WAS INITALLY SUGGESTED THAT THIS BE DONE AT A GLOBAL LEVEL, BUT THIS RESULTED IN COMPILER ERRORS.

SEM_INIT -
  THIS FUNCTION TAKES THE FOLLOWING INPUTS:
    *SEM - THE SEMAPHORE BEING INITIZALIZED
    PSHARED - THIS ARGUMENT WILL ALWAYS BE 0 FOR THESE PURPOSES (IE, THE SEMAPHORES WILL BE SHARED BETWEEN THREADS)
    VALUE - THE INITIAL VALUE OF THE SEMAPHORE

   THIS FUNCTION CREATES A SEMAPHORE, STORED IN SEM, WITH THE SUPPLIED VALUE

SEM_WAIT -
  THIS FUNCTION TAKES THE FOLLOWING INPUT:
    *SEM - THE SEMAPHORE BEING ACTED ON

  THIS FUNCTION DECREMENTS THE SEMAPHORE SEM - IF THE VALUE IS CURRENTLY 0, THE CALLING THREAD IS BLOCKED UNTIL IT 
  BECOMES POSSIBLE TO PERFORM THE DECREMENT.

SEM_POST -
  THIS FUNCTION TAKES THE FOLLOWING INPUT:
    *SEM - THE SEMAPHORE BEING ACTED ON

  THIS FUNCTION INCREMENTS THE SEMAPHORE SEM - IF THE VALUE BECOMES GREATER THAN 0, A THREAD BLOCKED BY SEM_WAIT IS 
  WOKEN UP AND PROCEEDS TO RUN. 

SEM_DESTROY -
  THIS FUNCTION TAKES THE FOLLOWING INPUT:
    *SEM - THE SEMAPHORE BEING DESTROYED

  THIS FUNCTION DESTORYS THE SEMAPHORE POINTED TO BY SEM, DEINITALIZING IT.
